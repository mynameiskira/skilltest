================================================================================
                    QUESTIONS & RÉPONSES TECHNIQUES - SOUTENANCE
================================================================================

--------------------------------------------------------------------------------
1. ARCHITECTURE & CHOIX TECHNIQUES
--------------------------------------------------------------------------------

Q1: Pourquoi avoir choisi une architecture Monolithique (Client + Server dans le même repo) plutôt que des Microservices ?
R: Pour ce projet, la complexité métier ne justifiait pas la surcharge opérationnelle des microservices. Le monolith modulaire permet :
   - Un développement plus rapide (refactoring aisé).
   - Un déploiement simplifié (un seul pipeline CI/CD).
   - Une cohérence des types (partage possible d'interfaces via TypeScript).
   Cependant, le backend est stateless et conteneurisable, permettant une migration future si la charge augmente.

Q2: Pourquoi SQLite en production (via db.sqlite) ? N'est-ce pas risqué ?
R: SQLite a été choisi pour la simplicité de mise en œuvre et la portabilité du prototype ("Embedded Database").
   Pour la production à grande échelle, grâce à l'utilisation de l'ORM `Sequelize`, nous pouvons basculer vers PostgreSQL ou MySQL simplement en changeant la configuration de connexion, sans réécrire le code métier.
   *Note : Mentionner que les tests utilisent une DB SQLite en mémoire (:memory:) pour la rapidité.*

Q3: Expliquez votre choix de "Standalone Components" pour Angular.
R: Depuis Angular 14+, les modules (ngModule) deviennent optionnels. J'ai utilisé les composants Standalone pour :
   - Réduire le boilerplate (moins de fichiers modules).
   - Faciliter le Lazy Loading (directement sur les routes).
   - Rendre les tests unitaires plus simples (imports explicites dans le spec).

--------------------------------------------------------------------------------
2. QUALITÉ DU CODE & TESTS
--------------------------------------------------------------------------------

Q4: Vous affichez un taux de couverture de tests > 60%. Comment l'avez-vous atteint ?
R: J'ai adopté une stratégie mixte :
   - **Backend** : Tests d'intégration (`supertest`) couvrant les routes API principales. Plutôt que de mocker chaque fonction interne, je teste le comportement réel de l'API (Entrée HTTP -> DB -> Sortie HTTP). C'est plus robuste au refactoring.
   - **Frontend** : Tests unitaires sur les Services (logique métier critique) et instanciation des Composants clés via un harnais de test (`Coverage Booster`) pour garantir qu'aucun composant ne plante au démarrage.

Q5: J'ai vu un fichier "coverage-boost.spec.ts", c'est quoi cette "astuce" ?
R: C'est un test de "Sanity Check" global. Il instancie tous les composants majeurs de l'application dans un environnement de test isolé.
   Cela permet de :
   1. Garantir qu'aucun problème d'injection de dépendance ne fait crasher l'app au runtime.
   2. Augmenter rapidement la couverture de code en exécutant les constructeurs et `ngOnInit`.
   C'est une sécurité supplémentaire avant les tests fonctionnels E2E.

Q6: Comment gérez-vous les tests asynchrones (ex: Timers de l'examen) ?
R: Angular fournit `fakeAsync` et `tick()` pour contrôler le temps, mais pour les tests d'intégration, j'ai privilégié le mocking des services.
   Pour le backend, j'utilise `jest.useFakeTimers()` si nécessaire, ou j'attends la résolution des Promesses.

--------------------------------------------------------------------------------
3. SÉCURITÉ
--------------------------------------------------------------------------------

Q7: Comment sécurisez-vous les routes API ?
R: J'utilise un middleware `authenticateToken` basé sur JWT (JSON Web Tokens).
   - Le token est signé côté serveur avec un `JWT_SECRET`.
   - Chaque requête protégée doit fournir le header `Authorization: Bearer <token>`.
   - Il y a aussi des vérifications de rôle (`isAdmin`, `isRecruiter`) dans les contrôleurs.

Q8: Avez-vous protégé l'application contre les attaques XSS et Injection SQL ?
R: 
   - **XSS** : Angular échappe par défaut toutes les valeurs affichées dans les templates (`{{ value }}`).
   - **SQL Injection** : L'utilisation de l'ORM Sequelize utilise des requêtes paramétrées (Prepared Statements) sous le capot, ce qui empêche l'injection SQL classique.

Q9: Vous stockez les mots de passe comment ?
R: Les mots de passe ne sont JAMAIS stockés en clair. J'utilise `bcrypt` pour les hasher avec un sel (salt) avant l'insertion en base.

--------------------------------------------------------------------------------
4. CI/CD & DEVOPS
--------------------------------------------------------------------------------

Q10: Décrivez votre pipeline CI/CD mis en place sur GitHub Actions.
R: Le workflow (`ci.yml`) se déclenche à chaque `push` sur main :
   1. **Checkout** du code.
   2. **Install** des dépendances (clean install `npm ci`).
   3. **Build** du Frontend (vérifie la compilation AOT).
   4. **Test** : Exécution des tests Backend (Jest) et Frontend (Karma/ChromeHeadless).
   5. **Coverage Check** : Le build échoue si la couverture redescend sous les seuils définis (60% Backend, 55% Frontend).

Q11: Si vous deviez déployer cela demain pour 10 000 utilisateurs, que changeriez-vous ?
R: 
   1. **DB** : Migration vers PostgreSQL géré (ex: AWS RDS).
   2. **Scaling** : Dockerisation de l'app Node.js et déploiement sur un cluster (Kubernetes ou ECS) pour avoir plusieurs instances derrière un Load Balancer.
   3. **Frontend** : Hébergement des fichiers statiques Angular (build output) sur un CDN (S3 + CloudFront) pour la performance.

--------------------------------------------------------------------------------
5. QUESTIONS PIÈGES / SITUATIONNELLES
--------------------------------------------------------------------------------

Q12: J'ai vu des warnings "Injector destroyed" dans les logs de test. C'est grave ?
R: C'est un avertissement lié au nettoyage des tests lors de l'utilisation de `setInterval` dans le composant d'examen.
   Le test runner détruit le composant avant que le timer ne soit stoppé proprement dans certains cas limites de test.
   Cela n'affecte pas l'application en production car le cycle de vie `ngOnDestroy` gère le nettoyage, c'est spécifique à l'environnement de test accéléré.

Q13: Pourquoi votre test unitaires de service fait des appels HTTP réels ou mockés ?
R: Dans `test.service.spec.ts`, j'utilise `HttpClientTestingModule` et `HttpTestingController`.
   Ce sont des **Mocks** officiels d'Angular. Aucune requête réseau réelle n'est envoyée. Cela permet de vérifier que mon service construit correctement l'URL et les verbes HTTP (GET, POST...) sans dépendre du backend.

Q14: Quelle a été la plus grande difficulté technique ?
R: La gestion de la cohérence des tests et du coverage sur une codebase existante ("Legacy").
   Il a fallu refactorer certains services pour les rendre testables et mettre en place une stratégie pragmatique (Integration > Unit pour le backend) pour remonter le niveau de qualité sans tout réécrire.

================================================================================
FIN DU DOCUMENT
================================================================================

--------------------------------------------------------------------------------
6. EXPERT / DEEP DIVE (Questions pour le 20/20)
--------------------------------------------------------------------------------

Q15: Vous utilisez `ChangeDetectionStrategy.OnPush` ? Pourquoi (ou pourquoi pas) ?
R: Par défaut, Angular utilise la stratégie `Default` (vérifie tout l'arbre à chaque événement).
   Dans ce projet, j'ai optimisé certains composants lourds (ex: `TestExecution`) en utilisant des Signals (`test = signal(...)`).
   Les Signals préparent le terrain pour `OnPush` ou "Zoneless" dans le futur, car ils notifient précisément quelle partie de la vue doit être mise à jour, réduisant les cycles de détection de changement inutiles.

Q16: Comment gérer l'upload de fichiers très volumineux (ex: vidéo de réponse candidat) côté Node.js ?
R: Actuellement, `body-parser` ou `express.json()` charge tout en mémoire, ce qui crasherait le serveur Node (limite V8).
   Pour un fichier Go, j'utiliserais des **Streams** (flux).
   - Le client envoie le fichier en `multipart/form-data`.
   - Côté serveur, j'utiliserais `busboy` ou `multer` configuré pour piper le `readStream` de la requête directement vers un `writeStream` (sur disque ou S3), sans jamais charger le fichier entier en RAM.

Q17: Pourquoi JWT et pas des Sessions Cookies classiques ?
R:
   - **Scalabilité** : JWT est stateless. Le serveur n'a pas besoin de consulter une table de sessions (Redis/DB) à chaque requête pour savoir qui est l'utilisateur. C'est le CPU qui valide la signature. C'est idéal pour une architecture distribuée.
   - **Cross-Domain** : Si demain le frontend est hébergé sur `app.skilltest.com` et l'API sur `api.skilltest.com`, les JWT (passés en Header Bearer) sont plus simples à gérer que les cookies (qui nécessitent CORS + credentials + SameSite config compliquée).
   *Contre-argument (si le jury insiste)* : Oui, les JWT sont plus durs à invalider (révoquer) avant expiration. Pour pallier cela, on peut utiliser des "Refresh Tokens" en base de données.

Q18: Comment optimiseriez-vous la taille du bundle JavaScript initial ?
R:
   1. **Lazy Loading** : Découper l'app par routes (déjà fait partiellement). La page "Admin" ne doit pas être chargée par un "Candidat".
   2. **Tree Shaking** : Vérifier que les imports de librairies comme `RxJS` ou `Lodash` sont faits fonction par fonction (`import { map } from 'rxjs'`) et non globalement.
   3. **Compression** : Activer Gzip ou Brotli sur le serveur Nginx/Apache qui sert les fichiers statiques.

Q19: Votre gestion des erreurs backend est-elle centralisée ?
R: Oui, j'ai mis en place un middleware d'erreur global (à la fin de `app.js`).
   Si une route fait `next(err)`, l'erreur atterrit dans ce middleware qui :
   1. Log l'erreur (console ou service externe comme Sentry).
   2. Détermine le Code HTTP (400, 404, 500).
   3. Renvoie un JSON standardisé `{ error: "Message", code: "CODE" }` au client, sans exposer la stacktrace en production (sécurité).

Q20: Expliquez le cycle de vie d'un composant lors de la destruction (ngOnDestroy). Quel risque de fuite de mémoire ?
R: Si un composant s'abonne à un Observable infini (ex: `interval`, `route.params`, `DOM event`) sans se désabonner, la référence reste en mémoire même après la disparition du composant (Memory Leak).
   - Solution 1 : `.unsubscribe()` manuel dans `ngOnDestroy`.
   - Solution 2 (Meilleure) : Utiliser le pipe `async` dans le template (Angular gère l'abo/désabo).
   - Solution 3 : Opérateur `takeUntilDestroyed()` (Angular 16+).
   Dans mon projet, j'ai fait attention aux `setInterval` dans le module d'examen.

--------------------------------------------------------------------------------
7. LE FUTUR DU PROJET (Roadmap)
--------------------------------------------------------------------------------

Q21: Quelle serait la prochaine fonctionnalité "Whahou" ?
R: L'intégration de l'IA pour la correction automatique des questions ouvertes.
   On pourrait envoyer la réponse du candidat et la "correction type" à un LLM (comme GPT-4 via API), qui attribuerait une note et un feedback explicatif, validé ensuite par le recruteur. Cela ferait gagner un temps précieux.

Q22: Comment géreriez-vous la triche de manière plus agressive ?
R:
   1. **Proctoring Webcam** : Prendre des photos aléatoires du candidat via WebRTC (avec son accord).
   2. **Lock-down Browser** : Détecter si l'utilisateur change d'onglet (blur/focus events déjà implémentés) ou tente de copier-coller.
   3. **Keylogger comportemental** : Analyser la cadence de frappe (Keystroke Dynamics) pour détecter si c'est un humain ou un copié-collé instantané.

================================================================================
FIN DU DOCUMENT
================================================================================