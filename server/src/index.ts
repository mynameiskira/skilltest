import express from 'express';
import type { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import PDFDocument from 'pdfkit';
import Stripe from 'stripe';
import sequelize from './config/database.js';
import { User, Test, Question, Result } from './models/index.js';

dotenv.config();

const app = express();
// TODO: Implement rate limiting for API endpoints using express-rate-limit
app.use(cors());
app.use(express.json());


// Global logger
app.use((req, res, next) => {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
    next();
});


const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret_placeholder';
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_placeholder_key_12345');

// Middleware to check authentication and roles
const authenticateToken = (req: any, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (!token) return res.sendStatus(401);

    jwt.verify(token, JWT_SECRET, (err: any, user: any) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
};

const authorizeRoles = (...roles: string[]) => {
    return (req: any, res: Response, next: NextFunction) => {
        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ message: 'Insufficient permissions' });
        }
        next();
    };
};

// Auth Routes
app.post('/api/auth/register', async (req: Request, res: Response) => {
    try {
        const { username, email, password, role } = req.body;
        const hashedPassword = await bcrypt.hash(password, 10);
        await User.create({ username, email, password: hashedPassword, role } as any);
        res.status(201).json({ message: 'User created successfully' });
    } catch (error: any) {
        res.status(400).json({ error: error.message });
    }
});

app.post('/api/auth/login', async (req: Request, res: Response) => {
    try {
        const { email, password } = req.body;
        const user: any = await User.findOne({ where: { email } });
        if (!user || !(await bcrypt.compare(password, user.password))) {
            return res.status(401).json({ message: 'Invalid credentials' });
        }
        const token = jwt.sign({ id: user.id, role: user.role, username: user.username }, JWT_SECRET, { expiresIn: '24h' });
        res.json({ token, user: { id: user.id, username: user.username, email: user.email, role: user.role } });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// CERTIFICATE GENERATION (PDF)
app.get('/api/results/:id/certificate', async (req: Request, res: Response) => {
    try {
        const result: any = await Result.findByPk(Number(req.params.id), {
            include: [User, Test]
        });

        if (!result) return res.status(404).send('Result not found');

        const doc = new PDFDocument({ size: 'A4', layout: 'landscape' });
        const filename = `Certificate_${result.User.username.replace(/\s+/g, '_')}.pdf`;

        res.setHeader('Content-disposition', `attachment; filename="${filename}"`);
        res.setHeader('Content-type', 'application/pdf');

        doc.pipe(res);

        // Aesthetics for the certificate
        doc.rect(0, 0, doc.page.width, doc.page.height).fill('#111111');

        // Border
        doc.rect(20, 20, doc.page.width - 40, doc.page.height - 40).strokeColor('#6366f1').lineWidth(5).stroke();

        // Content
        doc.fillColor('#6366f1').fontSize(40).text('CERTIFICATE OF ACHIEVEMENT', 100, 100, { align: 'center' });

        doc.fillColor('#ffffff').fontSize(20).text('This is to certify that', 100, 180, { align: 'center' });

        doc.fillColor('#ffffff').fontSize(45).font('Helvetica-Bold').text(result.User.username, 100, 230, { align: 'center' });

        doc.fillColor('#ffffff').fontSize(20).font('Helvetica').text('has successfully completed the assessment', 100, 310, { align: 'center' });

        doc.fillColor('#6366f1').fontSize(30).text(result.Test.title, 100, 350, { align: 'center' });

        doc.fillColor('#ffffff').fontSize(18).text(`Score: ${result.score} / ${result.maxScore}`, 100, 420, { align: 'center' });

        const date = result.completedAt ? new Date(result.completedAt).toLocaleDateString() : 'N/A';
        doc.fontSize(14).text(`Date: ${date}`, 100, 480, { align: 'center' });

        doc.fontSize(12).fillColor('#444444').text('Generated by SkillTest Enterprise Engine', 0, 550, { align: 'center' });

        doc.end();
    } catch (error: any) {
        res.status(500).send(error.message);
    }
});

// STRIPE CHECKOUT MOCK
app.post('/api/payments/checkout', authenticateToken, async (req: any, res: Response) => {
    try {
        const { planId } = req.body;
        // In a real app, you'd use stripe.checkout.sessions.create
        // Here we simulate a successful session URL
        res.json({ url: 'https://checkout.stripe.com/pay/mock_session_123' });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// USER MANAGEMENT (Admin only)
app.get('/api/admin/users', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
    try {
        const users = await User.findAll({ attributes: { exclude: ['password'] } });
        res.json(users);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/admin/users', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
    try {
        const { username, email, password, role } = req.body;
        const hashedPassword = await bcrypt.hash(password, 10);
        const user = await User.create({ username, email, password: hashedPassword, role } as any);
        res.status(201).json(user);
    } catch (error: any) {
        res.status(400).json({ error: error.message });
    }
});

app.delete('/api/admin/users/:id', authenticateToken, authorizeRoles('admin'), async (req: Request, res: Response) => {
    try {
        await User.destroy({ where: { id: req.params.id } });
        res.status(204).send();
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// TEST MANAGEMENT (Admin & Recruiter)
app.get('/api/tests', async (req: Request, res: Response) => {
    try {
        const tests = await Test.findAll({
            include: [{ model: User, as: 'creator', attributes: ['username'] }]
        });
        res.json(tests);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/tests/:id', async (req: Request, res: Response) => {
    try {
        const test: any = await Test.findByPk(Number(req.params.id), {
            include: [Question]
        });
        if (!test) return res.status(404).json({ message: 'Test not found' });
        res.json(test);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/tests', authenticateToken, authorizeRoles('admin', 'recruiter'), async (req: any, res: Response) => {
    console.log('DEBUG: POST /api/tests hit by user:', req.user.id);
    try {
        const { title, description, duration, language, questions } = req.body;
        const test: any = await Test.create({
            title,
            description,
            duration,
            language,
            createdBy: req.user.id
        } as any);

        if (questions && questions.length > 0) {
            const questionsData = questions.map((q: any) => ({ ...q, TestId: test.id }));
            await Question.bulkCreate(questionsData);
        }

        res.status(201).json(test);
    } catch (error: any) {
        res.status(400).json({ error: error.message });
    }
});

app.put('/api/tests/:id', authenticateToken, authorizeRoles('admin', 'recruiter'), async (req: any, res: Response) => {
    try {
        const { title, description, duration, language, questions } = req.body;
        const test: any = await Test.findByPk(Number(req.params.id));
        if (!test) return res.status(404).json({ message: 'Test not found' });

        // Only creator or admin can update
        if (req.user.role !== 'admin' && test.createdBy !== req.user.id) {
            return res.status(403).json({ message: 'Not authorized to edit this test' });
        }

        await test.update({ title, description, duration, language });

        if (questions) {
            await Question.destroy({ where: { TestId: test.id } });
            const questionsData = questions.map((q: any) => ({ ...q, TestId: test.id }));
            await Question.bulkCreate(questionsData);
        }

        res.json(test);
    } catch (error: any) {
        res.status(400).json({ error: error.message });
    }
});

app.delete('/api/tests/:id', authenticateToken, authorizeRoles('admin', 'recruiter'), async (req: any, res: Response) => {
    try {
        const test: any = await Test.findByPk(Number(req.params.id));
        if (!test) return res.status(404).json({ message: 'Test not found' });

        if (req.user.role !== 'admin' && test.createdBy !== req.user.id) {
            return res.status(403).json({ message: 'Not authorized to delete this test' });
        }

        await test.destroy();
        res.status(204).send();
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// RESULTS & SUBMISSIONS
app.post('/api/tests/:id/submit', async (req: Request, res: Response) => {
    try {
        const { answers, durationTaken, userId } = req.body;
        const test: any = await Test.findByPk(Number(req.params.id), { include: [Question] });

        if (!test) return res.status(404).json({ message: 'Test not found' });

        let score = 0;
        test.Questions.forEach((q: any) => {
            if (answers[q.id] === q.correctAnswer) {
                score += q.points;
            }
        });

        const maxScore = test.Questions.reduce((acc: number, q: any) => acc + q.points, 0);
        const scorePercentage = maxScore > 0 ? score / maxScore : 0;

        const result = await Result.create({
            UserId: userId,
            TestId: test.id,
            score,
            maxScore,
            status: 'completed',
            durationTaken,
            completedAt: new Date(),
            answers: answers,
            reviewStatus: scorePercentage < 0.7 ? 'pending' : null
        } as any);

        res.json(result);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/results', authenticateToken, authorizeRoles('admin', 'recruiter'), async (req: Request, res: Response) => {
    try {
        const results = await Result.findAll({
            include: [User, Test],
            order: [['completedAt', 'DESC']]
        });
        res.json(results);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// DASHBOARD FOR CANDIDATES (Specific results)
app.get('/api/candidates/:id/results', authenticateToken, async (req: Request, res: Response) => {
    try {
        const results = await Result.findAll({
            where: { UserId: req.params.id },
            include: [Test],
            order: [['completedAt', 'DESC']]
        });
        res.json(results);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// GET RESULT DETAILS FOR REVIEW (with questions and answers)
app.get('/api/results/:id/review', authenticateToken, authorizeRoles('admin', 'recruiter'), async (req: Request, res: Response) => {
    try {
        const result: any = await Result.findByPk(Number(req.params.id), {
            include: [
                { model: User, attributes: ['id', 'username', 'email'] },
                {
                    model: Test,
                    include: [{ model: Question }]
                }
            ]
        });

        if (!result) return res.status(404).json({ message: 'Result not found' });

        res.json(result);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// UPDATE REVIEW STATUS (approve or reject)
app.patch('/api/results/:id/review', authenticateToken, authorizeRoles('admin', 'recruiter'), async (req: any, res: Response) => {
    try {
        const { reviewStatus } = req.body; // 'approved' or 'rejected'

        if (!['approved', 'rejected'].includes(reviewStatus)) {
            return res.status(400).json({ message: 'Invalid review status' });
        }

        const result: any = await Result.findByPk(Number(req.params.id));
        if (!result) return res.status(404).json({ message: 'Result not found' });

        await result.update({
            reviewStatus,
            reviewedBy: req.user.id
        });

        res.json(result);
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});


const PORT = Number(process.env.PORT) || 5001;

if (require.main === module) {
    sequelize.sync().then(() => {
        app.listen(PORT, '0.0.0.0', () => console.log(`Server running on port ${PORT}`));
    }).catch(err => {
        console.error('Database connection failed:', err);
        app.listen(PORT, '0.0.0.0', () => console.log(`Server running on port ${PORT} (DB offline)`));
    });
}

export default app;
